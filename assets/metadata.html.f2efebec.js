import{_ as h,r as s,o as p,c as u,f as l,b as e,e as a,w as o,d as t,a as i}from"./app.33ffcc50.js";const m={},f=e("h1",{id:"metadata-layer",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#metadata-layer","aria-hidden":"true"},"#"),t(" Metadata Layer")],-1),y=e("p",null,[t("The metadata layer, generated as "),e("code",null,"metadata.g.ts"),t(", contains information about the types, properties, methods, and other components of your data model. Because Vue applications are typically compiled into a set of static assets, it is necessary for the frontend code to have a representation of your data model as an analog to the "),e("code",null,"ReflectionRepository"),t(" available at runtime to Knockout apps that utilize "),e("code",null,".cshtml"),t(" files.")],-1),_={class:"table-of-contents"},b=e("h2",{id:"concepts",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#concepts","aria-hidden":"true"},"#"),t(" Concepts")],-1),v={href:"https://github.com/IntelliTect/Coalesce/blob/dev/src/coalesce-vue/src/metadata.ts",target:"_blank",rel:"noopener noreferrer"},g=e("h3",{id:"metadata",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#metadata","aria-hidden":"true"},"#"),t(" Metadata")],-1),x=e("p",null,[t("All objects in the metadata layer that represent any kind of metadata have, at the very least, a "),e("code",null,"name"),t(", the name of the metadata element in code (type names, property names, parameter names, etc). and a "),e("code",null,"displayName"),t(", the human-readable form of the name that is suitable for presentation when needed. Names follow the casing convention of their corresponding language elements - types are PascalCased, while other things like properties, methods, and parameters are camelCased.")],-1),T=e("h3",{id:"type",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#type","aria-hidden":"true"},"#"),t(" Type")],-1),k=e("code",null,"model",-1),C=e("code",null,"object",-1),V=e("h3",{id:"value",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#value","aria-hidden":"true"},"#"),t(" Value")],-1),w=e("p",null,"In the metadata layer, a Value is the usage of a type. This could be any type - strings, numbers, enums, classes, or even void. Values can be found in the collection of an object's properties, a method's parameters or return value, or as a data source's parameters.",-1),R=e("p",null,"All values have the following properties:",-1),N=i("<p>Type could be a language primitive like <code>string</code> or <code>number</code>, a non-primitive JavaScript type (<code>date</code>, <code>file</code>), or in the case of a custom Type, the type kind of that type (<code>model</code>, <code>enum</code>, <code>object</code>). For custom types, an additional property <code>typeDef</code> will refer to the Type metadata for that type.</p>",1),E=i('<p>Role represents what purpose the value serves in a relational model. Either <code>value</code> (the default - no relational role), <code>primaryKey</code>, <code>foreignKey</code>, <code>referenceNavigation</code>, or <code>collectionNavigation</code>.</p><h3 id="property" tabindex="-1"><a class="header-anchor" href="#property" aria-hidden="true">#</a> Property</h3><p>A Property is a more refined Value that contains a number of additional fields based on the <code>role</code> of the property. k</p><h3 id="domain" tabindex="-1"><a class="header-anchor" href="#domain" aria-hidden="true">#</a> Domain</h3><p>The type of the default export of the generated metadata. Serves as a single root from which all other metadata can be accessed. Contains fields <code>types</code>, <code>enums</code>, and <code>services</code> as organizing structures for the different kinds of custom types.</p>',5);function A(M,P){const n=s("router-link"),c=s("ExternalLinkIcon"),d=s("RouterLink"),r=s("Prop");return p(),u("div",null,[f,l(" MARKER:summary "),y,l(" MARKER:summary-end "),e("nav",_,[e("ul",null,[e("li",null,[a(n,{to:"#concepts"},{default:o(()=>[t("Concepts")]),_:1}),e("ul",null,[e("li",null,[a(n,{to:"#metadata"},{default:o(()=>[t("Metadata")]),_:1})]),e("li",null,[a(n,{to:"#type"},{default:o(()=>[t("Type")]),_:1})]),e("li",null,[a(n,{to:"#value"},{default:o(()=>[t("Value")]),_:1})]),e("li",null,[a(n,{to:"#property"},{default:o(()=>[t("Property")]),_:1})]),e("li",null,[a(n,{to:"#domain"},{default:o(()=>[t("Domain")]),_:1})])])])])]),b,e("p",null,[t("The following is a non-exhaustive list of the general concepts used by the metadata layer. The "),e("a",v,[t("source code of coalesce-vue"),a(c)]),t(" provides the most exhaustive set of documentation about the metadata layer:")]),g,x,T,e("p",null,[t("All custom types exposed by your application's data model will have a Type metadata object generated. This includes both C# classes, and C# enums. Class types include "),k,t(" (for "),a(d,{to:"/modeling/model-types/entities.html"},{default:o(()=>[t("Entity Models")]),_:1}),t(" and "),a(d,{to:"/modeling/model-types/dtos.html"},{default:o(()=>[t("Custom DTOs")]),_:1}),t(") and "),C,t(" (for "),a(d,{to:"/modeling/model-types/external-types.html"},{default:o(()=>[t("External Types")]),_:1}),t(").")]),V,w,R,a(r,{def:"type: TypeDiscriminator",lang:"ts"}),N,a(r,{def:"role: ValueRole",lang:"ts"}),E])}const D=h(m,[["render",A],["__file","metadata.html.vue"]]);export{D as default};
